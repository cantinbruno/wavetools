<!DOCTYPE html>
<html lang="fr">
<body>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Home — WaveTools</title>
  <meta name="description" content="WaveTools : des outils IT gratuits, rapides et fiables pour simplifier le travail des administrateurs réseau et système.">
  <meta name="robots" content="index, follow">
  <meta http-equiv="content-language" content="fr">
  <meta name="author" content="WaveTools">
  <link rel="canonical" href="https://www.wavetools.fr">
  <link rel="icon" href="./img/favicon.ico?v=3">
  <link rel="stylesheet" href="./includes/style.css">
</head>

<div id="header"></div>

<main class="liquid-hero" id="liquidHero">
  <canvas class="liquid-hero__canvas" id="liquidCanvas" aria-hidden="true"></canvas>

  <!-- overlay scanlines + vignette -->
  <div class="liquid-hero__overlays" aria-hidden="true">
    <div class="liquid-hero__scanlines"></div>
    <div class="liquid-hero__vignette"></div>
  </div>

  <section class="liquid-hero__content">
    <div class="liquid-hero__card">
      <div class="liquid-hero__badge">
        <span class="liquid-hero__dot"></span>
        WaveTools • Outils IT gratuits
      </div>

      <h1 class="liquid-hero__title">WaveTools</h1>
      <p class="liquid-hero__subtitle">
        Bienvenue sur la plateforme d’outils IT gratuits : réseau, sécurité, diagnostics.
      </p>

      <div class="liquid-hero__actions">
        <a class="btn btn--primary" href="#outils">Découvrir les outils</a>
        <a class="btn btn--ghost" href="#contact">Contact</a>
      </div>
    </div>
  </section>

  <!-- Glitch layer on hover -->
  <div class="liquid-hero__glitch" aria-hidden="true"></div>
</main>

<script>
(() => {
  const hero = document.getElementById("liquidHero");
  const canvas = document.getElementById("liquidCanvas");
  const ctx = canvas.getContext("2d", { alpha: true });

  let W = 0, H = 0, DPR = 1;
  let t = 0;
  let mouseX = 0.5, mouseY = 0.5;
  let hover = false;
  let scrollY = 0;

  // --- Resize (fit to main only)
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = hero.clientWidth;
    H = hero.clientHeight;

    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }

  // --- Smooth scroll value (parallax)
  let targetScroll = 0;
  function onScroll() {
    // relative scroll position of the hero in viewport
    const r = hero.getBoundingClientRect();
    const vh = window.innerHeight || 1;
    // -1 .. 1 (approx) where 0 is centered
    targetScroll = ((r.top + r.height * 0.5) - vh * 0.5) / (vh * 0.5);
  }

  // --- Mouse (for ripple intensity + glitch)
  hero.addEventListener("pointermove", (e) => {
    const r = hero.getBoundingClientRect();
    mouseX = (e.clientX - r.left) / Math.max(1, r.width);
    mouseY = (e.clientY - r.top) / Math.max(1, r.height);
  });
  hero.addEventListener("pointerenter", () => { hover = true; hero.classList.add("is-hover"); });
  hero.addEventListener("pointerleave", () => { hover = false; hero.classList.remove("is-hover"); });

  // --- Liquid shader-like field (2D)
  // We generate a smooth field using multiple traveling sine waves + a swirl near cursor
  function field(x, y, time) {
    const nx = x / W, ny = y / H;

    const a = Math.sin((nx * 10.0 + time * 0.9) + Math.sin(ny * 6.0 - time * 0.6));
    const b = Math.cos((ny * 9.0 - time * 0.7) + Math.cos(nx * 7.0 + time * 0.5));
    const c = Math.sin((nx * 5.0 + ny * 4.0) * 2.0 + time * 0.4);

    // cursor swirl
    const dx = nx - mouseX, dy = ny - mouseY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const swirl = Math.cos(dist * 18.0 - time * 2.2) * Math.exp(-dist * 6.5);

    // parallax influence
    const p = scrollY; // -something..something
    const par = Math.sin((nx*3.0 - ny*2.0) + p*1.1);

    return (a*0.45 + b*0.35 + c*0.25 + swirl*0.9 + par*0.18);
  }

  function draw() {
    // smooth scroll
    scrollY += (targetScroll - scrollY) * 0.08;

    // time
    t += 0.016;

    ctx.clearRect(0, 0, W, H);

    // performance: draw by tiles (shader-like, but faster than per-pixel)
    const tile = 6; // lower = more detailed, higher = faster
    for (let y = 0; y < H; y += tile) {
      for (let x = 0; x < W; x += tile) {
        const v = field(x + tile*0.5, y + tile*0.5, t);

        // map field to hue/alpha (neon aurora)
        const hue = 190 + v * 35; // cyan/purple range
        const alpha = 0.10 + Math.min(0.45, Math.abs(v) * 0.22);

        ctx.fillStyle = `hsla(${hue}, 95%, 60%, ${alpha})`;
        ctx.fillRect(x, y, tile, tile);
      }
    }

    // add a soft gradient fog on top
    const g = ctx.createRadialGradient(W*0.28, H*0.25, 0, W*0.28, H*0.25, Math.max(W, H));
    g.addColorStop(0, "rgba(0,212,255,0.12)");
    g.addColorStop(0.5, "rgba(106,92,255,0.08)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // subtle "glitch jitter" when hover (canvas shifting)
    if (hover && Math.random() < 0.16) {
      const jx = (Math.random() - 0.5) * 6;
      const jy = (Math.random() - 0.5) * 5;
      hero.style.setProperty("--glitch-x", jx + "px");
      hero.style.setProperty("--glitch-y", jy + "px");
      hero.style.setProperty("--glitch-a", (0.35 + Math.random()*0.35).toFixed(2));
    } else {
      hero.style.setProperty("--glitch-x", "0px");
      hero.style.setProperty("--glitch-y", "0px");
      hero.style.setProperty("--glitch-a", "0");
    }

    requestAnimationFrame(draw);
  }

  // init
  resize();
  onScroll();
  window.addEventListener("resize", resize);
  window.addEventListener("scroll", onScroll, { passive: true });

  // first paint after layout
  requestAnimationFrame(draw);
})();
</script>

<div id="footer"></div>
<script src="./includes/auto.js"></script>
</body>
</html>